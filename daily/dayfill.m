function Y=dayfill(X,W,mask)
% Fill in missing daily ppt values with calls to dayest2.m
%
% D Meko 11-1-94
%
%********************  IN ARGS  **************************
% 
%
% X (mX x nX) matrix of daily ppt for nX-2 stations and mX Julian days.
%	Col 1 is the calendar year.  Col 2 is the Julian day, 1-366.  Remaining
%	cols are the ppt values for each station.  X can be read in originally
%	before starting the function from an ascii array generated by fortran
%	program by Gregg Garfin.
%
% W (mW x 5) pointer to cols of X holding predictor stations.
%	Each row stands for a key station, mW total stations.
%	Col 1 gives the sequence number in X of the most preferred predictor 
%	station.  W is built before running this function by common sense by 
%	setting priorities of stations based on proximity and similar climate
%	regimes.  After running program, spearman r and other output gives 
%	feedback on how reasonable your priorities are.
%
% mask (1 x mW)i    mask to allow running the function for just a
%		few stations.  1=do this stn   0= skip this stn
%
%
%
%%*************************  OUT ARGS *************************
%
% Y (mY x nY)  the filled-in equivalent of X.  Should contain no missing
%	values.
%
%*********    NOTES *************
%
% Given a key station with some missing daily ppt values, and a set of
% other stations with daily ppt data.  Using climatological reasoning, set
% a priority for the other stations as predictor stations
% for estimating missing data at the key station.  The priority can be
% based on distance between stations, similarity of climatological
% or some other criterion.
%
% Loop through predictor stations beginning with highest priority.
% Estimate all missing values possible from that predictor.  Then
% move on to second priority station, and estimate as many possible
% remaining missing values from that station, and so forth.
%
% Call to dayest2 estimates by median-ratio method
%
%


% Size and check inputs 
[mX,nX]=size(X);
[mW,nW]=size(W);
[ml,nl]= size(mask);
% check that mask has right dimensions and is logical vector
if ml~=1 | nl~=mW
	error('mask should be row vector same length as row size of W')
end
if sum([(mask==1)  (mask==0)]) ~= mW
	error ('mask should be logical -- all entries 1 or 0')
end


% Truncate last cols of W if fewer than 5 predictors used
zz = any(W==0);
if any(zz)
	W(:,zz)=[];
end
[mW,nW]=size(W);





% Initialize the filled in matrix as the original matrix
Y = X;

% Pull out subset of of rows of W corresponding to key stations
% to treat in this run.  
W1=W(mask,:); 
[mW1,nW1]=size(W1); % mW1 will equal number of key stations to treat

xmiss=-1.111;  % hard code missing value indicator
rowX =find(mask); % row index to rows of W corresponding to those
	% key stations to treat in this run

for i=1:mW1; % loop over key stations
	disp(['On ',int2str(i),'th key station'])
	xk = X(:,rowX(i)+2);  % pull out the key station
	xeold=xk;  % initialize the "old" estimate as the original data 

	for j=1:nW1 ;  % loop over the predictor stations
		disp(['On ',int2str(j),'th predictor']);
		colp = W1(i,j)+2;  % column in X holding this predictor station
		xp = X(:,colp);   % the predictor variable
		xe = dayest2(xk,xp,xmiss,xeold) ;  %  estimate for key stn
		xeold = xe;  % update the "old" estimate
	end
	Y(:,rowX(i)+2)=xe;  
end



